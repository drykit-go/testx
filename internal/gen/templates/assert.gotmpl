// Package checkconv provides functions to convert typed checkers
// into generic ones.
//
// TODO: delete package checkconv
package checkconv

import (
	"context"
	"net/http"
	"time"

	"github.com/drykit-go/testx/check"
)

{{range . -}}
{{if ne .N "Value"}}
// From{{.N}} returns a check.Checker[interface{}] that wraps the given
// check.Checker[{{.T}}], so it can be used as a generic checker.
func From{{.N}}(c check.Checker[{{.T}}]) check.Checker[interface{}] {
	return check.NewChecker(
		func(got interface{}) bool { return c.Pass(got.({{.T}})) },
		c.Explain,
	)
}
{{end}}
{{end}}

// Assert returns a check.Checker[interface{}] that wraps the given
// check.Checker[T].
//
// It panics if checker is not a known checker type. For instance,
// a custom checker that implements check.IntChecker will be successfully
// converted, while a valid implementation of an unknown interface,
// such as Complex128Checker, will panic.
// For that matter, Cast should be used instead.
func Assert(knownChecker interface{}) check.Checker[interface{}] {
	switch c := knownChecker.(type) {
	{{range . -}}
	case check.Checker[{{.T}}]:
	{{if ne .N "Value" -}}
		return From{{.N}}(c)
	{{else -}}
		return c
	{{end -}}
	{{end -}}
	default:
		panic("assert from unknown checker type")
	}
}

// AssertMany returns a slice of check.Checker[interface{}] that wrap the given
// check.Checker[T].
//
// It panics if any checker is not a known checker type. See Assert
// for further documentation.
func AssertMany(knownCheckers ...interface{}) []check.Checker[interface{}] {
	valueCheckers := []check.Checker[interface{}]{}
	for _, c := range knownCheckers {
		valueCheckers = append(valueCheckers, Assert(c))
	}
	return valueCheckers
}
