// Code generated by go generate ./...; DO NOT EDIT
// Last generated on 31 Oct 21 17:02 UTC

// Package checkconv provides functions to convert typed checkers
// into generic ones.
//
// TODO: delete package checkconv
package checkconv

import (
	"context"
	"net/http"
	"time"

	"github.com/drykit-go/testx/check"
)


// FromBool returns a check.Checker[any] that wraps the given
// check.Checker[bool], so it can be used as a generic checker.
func FromBool(c check.Checker[bool]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(bool)) },
		c.Explain,
	)
}


// FromBytes returns a check.Checker[any] that wraps the given
// check.Checker[[]byte], so it can be used as a generic checker.
func FromBytes(c check.Checker[[]byte]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.([]byte)) },
		c.Explain,
	)
}


// FromString returns a check.Checker[any] that wraps the given
// check.Checker[string], so it can be used as a generic checker.
func FromString(c check.Checker[string]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(string)) },
		c.Explain,
	)
}


// FromInt returns a check.Checker[any] that wraps the given
// check.Checker[int], so it can be used as a generic checker.
func FromInt(c check.Checker[int]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(int)) },
		c.Explain,
	)
}


// FromFloat64 returns a check.Checker[any] that wraps the given
// check.Checker[float64], so it can be used as a generic checker.
func FromFloat64(c check.Checker[float64]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(float64)) },
		c.Explain,
	)
}


// FromDuration returns a check.Checker[any] that wraps the given
// check.Checker[time.Duration], so it can be used as a generic checker.
func FromDuration(c check.Checker[time.Duration]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(time.Duration)) },
		c.Explain,
	)
}


// FromContext returns a check.Checker[any] that wraps the given
// check.Checker[context.Context], so it can be used as a generic checker.
func FromContext(c check.Checker[context.Context]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(context.Context)) },
		c.Explain,
	)
}


// FromHTTPHeader returns a check.Checker[any] that wraps the given
// check.Checker[http.Header], so it can be used as a generic checker.
func FromHTTPHeader(c check.Checker[http.Header]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(http.Header)) },
		c.Explain,
	)
}


// FromHTTPRequest returns a check.Checker[any] that wraps the given
// check.Checker[*http.Request], so it can be used as a generic checker.
func FromHTTPRequest(c check.Checker[*http.Request]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(*http.Request)) },
		c.Explain,
	)
}


// FromHTTPResponse returns a check.Checker[any] that wraps the given
// check.Checker[*http.Response], so it can be used as a generic checker.
func FromHTTPResponse(c check.Checker[*http.Response]) check.Checker[any] {
	return check.NewChecker(
		func(got any) bool { return c.Pass(got.(*http.Response)) },
		c.Explain,
	)
}




// Assert returns a check.Checker[any] that wraps the given
// check.Checker[T].
//
// It panics if checker is not a known checker type. For instance,
// a custom checker that implements check.IntChecker will be successfully
// converted, while a valid implementation of an unknown interface,
// such as Complex128Checker, will panic.
// For that matter, Cast should be used instead.
func Assert(knownChecker any) check.Checker[any] {
	switch c := knownChecker.(type) {
	case check.Checker[bool]:
	return FromBool(c)
	case check.Checker[[]byte]:
	return FromBytes(c)
	case check.Checker[string]:
	return FromString(c)
	case check.Checker[int]:
	return FromInt(c)
	case check.Checker[float64]:
	return FromFloat64(c)
	case check.Checker[time.Duration]:
	return FromDuration(c)
	case check.Checker[context.Context]:
	return FromContext(c)
	case check.Checker[http.Header]:
	return FromHTTPHeader(c)
	case check.Checker[*http.Request]:
	return FromHTTPRequest(c)
	case check.Checker[*http.Response]:
	return FromHTTPResponse(c)
	case check.Checker[any]:
	return c
	default:
		panic("assert from unknown checker type")
	}
}

// AssertMany returns a slice of check.Checker[any] that wrap the given
// check.Checker[T].
//
// It panics if any checker is not a known checker type. See Assert
// for further documentation.
func AssertMany(knownCheckers ...any) []check.Checker[any] {
	valueCheckers := []check.Checker[any]{}
	for _, c := range knownCheckers {
		valueCheckers = append(valueCheckers, Assert(c))
	}
	return valueCheckers
}
